JavaScript Basics

Synchronous: Executes one line of code at a time.

Single-threaded: JavaScript runs on a single thread. It may seem slow, but it doesn’t feel slow because JS is usually run in environments like browsers or Node.js, which handle asynchronous tasks for it.

Execution Context: Executes code line by line. It consists of:

Call Stack – keeps track of function calls

Memory Heap – stores objects and variables

Blocking vs Non-blocking Code:

Blocking code: Stops the execution of the program until it completes.

Non-blocking code: Does not stop the execution; other code continues running.

Important Functions

setTimeout()

setInterval()

clearTimeout()

clearInterval()

Promise

“When you make a request with a Promise using fetch, a 404 error still returns a resolved response (not a rejection). You only get a rejected promise if the request itself fails to reach the server (e.g., network error, no internet, or blocked by the browser).”

Fetch and Microtasks

fetch() operates in the Microtask Queue (highest priority).

Example flow of fetch():

fetch('some-api-url')
  ↓
Browsers/Node.js handle the API/network request
  ↓
Data is reserved in memory
  ↓
Promise’s internal slots:
    - [[OnFulfilled]] – stores callbacks for successful resolution
    - [[OnRejected]]  – stores callbacks for rejection
(Note: These internal arrays are private and cannot be modified directly)


✅ Key Points:

fetch() always returns a Promise.

HTTP errors like 404 do not reject the Promise; you need to check response.ok.

Only network-level failures trigger a rejection and go to .catch().