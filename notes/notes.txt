JavaScript Basics

Synchronous: Executes one line of code at a time.

Single-threaded: JavaScript runs on a single thread. It may seem slow, but it doesn’t feel slow because JS is usually run in environments like browsers or Node.js, which handle asynchronous tasks for it.

Execution Context: Executes code line by line. It consists of:

Call Stack – keeps track of function calls

Memory Heap – stores objects and variables

Blocking vs Non-blocking Code:

Blocking code: Stops the execution of the program until it completes.

Non-blocking code: Does not stop the execution; other code continues running.

Important Functions

setTimeout()

setInterval()

clearTimeout()

clearInterval()

Promise

“When you make a request with a Promise using fetch, a 404 error still returns a resolved response (not a rejection). You only get a rejected promise if the request itself fails to reach the server (e.g., network error, no internet, or blocked by the browser).”

Fetch and Microtasks

fetch() operates in the Microtask Queue (highest priority).

Example flow of fetch():

fetch('some-api-url')
  ↓
Browsers/Node.js handle the API/network request
  ↓
Data is reserved in memory
  ↓
Promise’s internal slots:
    - [[OnFulfilled]] – stores callbacks for successful resolution
    - [[OnRejected]]  – stores callbacks for rejection
(Note: These internal arrays are private and cannot be modified directly)


✅ Key Points:

fetch() always returns a Promise.

HTTP errors like 404 do not reject the Promise; you need to check response.ok.

Only network-level failures trigger a rejection and go to .catch().



#this
In browser JavaScript, when you just type console.log(this) in the global scope, it refers to the global object, which is the window object.
window is the global object in browsers, holding things like document, console, setTimeout, etc.

in short- In the browser, this in the global scope refers to the window object (the global object).
In Node.js, this in the global scope is an empty object {},


 ## new 
 1. A brand-new empty object is created.
 2. The constructor function is called with 'this' bound to that new object.
 3. Properties and values are assigned to the object via 'this'.
 4. Unless the constructor explicitly returns another object, 
   the newly created object is returned by default.



#instanceof
instanceof checks whether an object is created by (or inherits from) a specific constructor function/class.
It returns true if the object is an instance of that constructor, otherwise false.

Example:

function Person(name) {
  this.name = name;
}

const p1 = new Person("Arnav");

console.log(p1 instanceof Person); // true
console.log(p1 instanceof Object); // true
console.log(p1 instanceof Array);  // false